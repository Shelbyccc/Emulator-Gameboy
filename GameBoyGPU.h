#pragma once

#include "GameBoyDefs.h"
#include <vector>

namespace GameBoy
{

	class Memory;
	class Interrupts;

	const int VRAMBankSize = 0x2000;

	class GPU
	{
	public:
		/*
		Состояния LCD-контроллера
		*/
		enum GameboyLCDModes
		{
			GBLCDMODE_OAM = 2,		//Данное состояние означает, что LCD-контроллер использует OAM память.
			//CPU она не доступна, зато пока еще доступна видеопамять.

			GBLCDMODE_OAMRAM = 3,	//Используются как OAM, так и VRAM. ЦП не может получить доступ в течение этого периода
			//Здесь выполняется весь рендеринг. Длится (172 + (SCX % 8) + спрайтов) циклов
			//Спрайты заставляют этот режим занять больше времени

			GBLCDMODE_HBLANK = 0,	//Период H - Blank.CPU может получить доступ к VRAM и OAM
			//Это состояние означает две вещи. Первое, была выведена одна строка.
			//Второе, видеопамять и OAM не используются LCD-контроллером и доступны CPU.
			//Длится (204 - (SCX % 8) - Sprites) циклов
			//Здесь контроллер ЖК дисплея фиксирует задержку режима 3, поэтому сканирующая линия будет занимать ровно 456 циклов

			GBLCDMODE_VBLANK = 1	//Состояние означает две вещи. Первое, были выведены все 144 видимые строки.
			//Второе, видеопамять и OAM не используются LCD-контроллером и доступны CPU.
		};

		//Внутренний набор состояний
		enum InternalLCDModes
		{
			LCDMODE_LY00_HBLANK,
			LCDMODE_LYXX_HBLANK,
			LCDMODE_LYXX_HBLANK_INC,
			LCDMODE_LY00_VBLANK,
			LCDMODE_LY9X_VBLANK,
			LCDMODE_LY9X_VBLANK_INC,
			LCDMODE_LYXX_OAM,
			LCDMODE_LYXX_OAMRAM
		};

		GPU(Interrupts& INT);

		void Step(DWORD clockDelta, Memory& MMU);

		void Reset();
		void EmulateBIOS();

		const DWORD** GetFramebuffer() { return (const DWORD**)Framebuffer; }	//возвращаем новый кадр
		bool IsNewFrameReady() { return NewFrameReady; }	//узнать, сформировался ли новый кадр
		void WaitForNewFrame() { NewFrameReady = false; }	//установка того, что нового кадра нет

		void WriteVRAM(WORD addr, BYTE value);				//запись в видеопамять
		void WriteOAM(BYTE addr, BYTE value);				//запись в память спрайтов	
		BYTE ReadVRAM(WORD addr);							//чтение из видеопамяти
		BYTE ReadOAM(BYTE addr);							//чтение из памяти спрайтов

		void DMAStep(Memory& MMU);		//прямой доступ к памяти для рисования строки
		void DMAChanged(BYTE value);	//изменение адреса фрагмента, с которым взаимодействует контроллер		
		//Изменение значений регистров
		void LCDCChanged(BYTE value);						
		void STATChanged(BYTE value);
		void SCYChanged(BYTE value) { SCY = value; }
		void SCXChanged(BYTE value) { SCX = value; }
		void LYChanged(BYTE value) { LY = 0; }
		void LYCChanged(BYTE value);
		void BGPChanged(BYTE value) { BGP = value; }
		void OBP0Changed(BYTE value) { OBP0 = value; }
		void OBP1Changed(BYTE value) { OBP1 = value; }
		void WYChanged(BYTE value) { WY = value; }
		void WXChanged(BYTE value) { WX = value; }

		//Получение значений регистров
		BYTE GetLCDC() { return LCDC; }
		BYTE GetSTAT() { return STAT | 0x80; }
		BYTE GetSCY() { return SCY; }
		BYTE GetSCX() { return SCX; }
		BYTE GetLY() { return LY; }
		BYTE GetLYC() { return LYC; }
		BYTE GetBGP() { return BGP; }
		BYTE GetOBP0() { return OBP0; }
		BYTE GetOBP1() { return OBP1; }
		BYTE GetWY() { return WY; }
		BYTE GetWX() { return WX; }
	private:

		void RenderScanline();				//отрисовка строки
		void CheckLYC(Interrupts &INT);		//разрешить LCDC прерывание в случае равенства регистров LY и LYC
		void PrepareSpriteQueue();			//очередь спрайтов

		Interrupts& INT;					//прерывания

		//GPU память
		BYTE VRAM[VRAMBankSize * 2];
		BYTE OAM[0xA0 + 0x5F];				//используется дополнительная память 0x5F для предотвращения Sprite RAM Bug,
											//когда в OAM записывается мусор

		//GPU регистры
		BYTE LCDC;	/*Регистр управления видеопроцессором LCDC 
		Адрес: FFA0h. 
		Тип: запись/чтение. 
		Назначение разрядов: 
		D7 - разрешение работы видеопроцессора: 
		0 - видеопроцессор выключен, изображение на экране отсутствует.
		1 - видеопроцессор включен. 
		D6 - выбор экранной страницы, хранящей изображение окна: 
		0 - 9800h - 9BFFh; 
		1 - 9C00h - 9FFFh. 
		D5 - разрешение вывода окна на экран: 
		0 - не выводится; 
		1 - выводится. 
		D4 - выбор знакогенератора для хранения элементов фона и окна: 
		0 - знакогенератор расположен по адресам 8800h - 97FFh; 
		1 - знакогенератор расположен по адресам 8000h - 8FFFh (здесь же содержатся изображения спрайтов). 
		D3 - выбор экранной страницы для хранения фона: 
		0 - 9800h - 9BFFh; 
		1 - 9C00h- 9FFFh. 
		D2 - задание размера спрайтов: 
		0 - 8x8; 
		1 - 8x16. 
		D1 - разрешение вывода спрайтов на экран: 
		0 - не выводятся; 
		1 - выводятся. 
		D0 - разрешение вывода фона и окна на экран: 
		0 - не выводятся; 
		1 - выводятся.*/

		BYTE STAT;	//LCDC статус (R/W)
		//6	Разрешить LCDC прерывание в случае равенства регистров LY и LYC
		//5	Разрешить LCDC прерывание при переходе в состояние 2
		//4	Разрешить LCDC прерывание при переходе в состояние 1
		//3	Разрешить LCDC прерывание при переходе в состояние 0
		//2	Бит установлен, если LY и LYC равны.Сброшен иначе
		//0 - 1	Текущее состояние

		BYTE SCY;	/*Регистр вертикальной координаты экрана SCY 
		Адрес: FF42h. 
		Тип: запись/чтение. 
		Назначение разрядов. 
		Записываемое в регистр 8-разрядное значение задает вертикальную координату верхнего левого угла выводимого фрагмента экранной страницы.
		Изменяя его, можно плавно прокручивать фоновое изображение на экране.*/

		BYTE SCX;	/*Регистр горизонтальной координаты экрана SCX 
		Адрес: FF43h. 
		Тип: запись/чтение. 
		Назначение разрядов. 
		Записываемое в регистр 8-разрядное значение задает горизонтальную координату верхнего левого угла выводимого фрагмента экранной страницы.
		Изменяя его, можно плавно прокручивать фоновое изображение на экране.*/

		BYTE LY;	/*Регистр номера формируемой строки LY 
		Адрес: FF44h. 
		Тип: чтение. 
		Назначение разрядов. 
		В регистре находится информация о номере строки экрана, формируемой в данный момент видеопроцессором.
		Значения 0-143 соответствуют номерам строк экрана, начиная с верхней. Во время генерации кадрового синхроимпульса значение,
		хранящееся здесь, изменяется от 144 до 153.*/

		BYTE LYC;	/*Регистр номера строки LYC 
		Адрес: FF45h. 
		Тип: чтение/запись. 
		Назначение разрядов. 
		В регистр записывается произвольное 8-разрядное значение. Когда номер формируемой строки, находящийся в регистре LY,
		совпадает с значением, заданным в регистре LYC, разряд D2 регистра состояния видеопроцессора STAT становится равен 1. 
		Если при этом разряд D6 регистра STAT также установлен в 1, видеопроцессор генерирует запрос на прерывание.*/

		BYTE BGP;	/*Регистр палитры фона BGP
		Адрес : FF47h.
		Тип : запись / чтение.
		Назначение разрядов.
		Когда видеопроцессор совмещает два битовых образа строки символа из знакогенератора, каждая точка на экране кодируется комбинацией
		из двух битов : 00, 01, 10 или 11. Однако это значение является не кодом выводимого цвета, а индексом определенной палитры.
		Из регистра палитры выбираются два бита, соответствующие коду точки, которые и являются цветом, отображаемым на экране.
		Содержимое регистра влияет на изображение фона и окна.
		7,6 - цвет точки с кодом 11;
		5,4 - цвет точки с кодом 10;
		3,2 - цвет точки с кодом 01;
		1,0 - цвет точки с кодом 00.*/

		BYTE OBP0;	/*Регистр палитры спрайтов 1 ОВР0 
		Адрес: FF48h. 
		Тип: чтение/запись. 
		Назначение разрядов. 
		Этот регистр используется так же, как и регистр BGP, только его содержимое влияет на цвет спрайтов,
		у которых разряд D4 в байте атрибутов равен 0.*/

		BYTE OBP1;	/*Регистр палитры спрайтов 2 ОВР1 
		Адрес: FF49h. 
		Тип: чтение/запись. 
		Назначение разрядов. 
		Регистр применяется так же, как и регистр BGP, только его содержимое влияет на цвет спрайтов,
		у которых разряд D4 в байте атрибутов равен 1.*/

		BYTE WY;	/*Регистр вертикальной координаты окна WY 
		Адрес: FF4Ah. 
		Тип: чтение/запись. 
		Назначение разрядов. 
		В регистр записывается номер строки экрана, начиная с которой видеопроцессор отображает окно.
		Если значение превышает 143, окно выводиться не будет.*/

		BYTE WX;	/*Регистр горизонтальной координаты окна WX 
		Адрес: FF4Bh. 
		Тип: чтение/запись. 
		Назначение разрядов. 
		В регистр записывается номер точки в строке экрана, начиная с которой видеопроцессор отображает окно.
		Если значение превышает 166, окно выводиться не будет. Содержимое регистра должно быть на 7 больше,
		чем реальная координата границы окна на экране. */

		DWORD GB2RGBPalette[4];			//Gameboy палитра
		DWORD SpriteClocks[11];			//Для разного количества спрайтов надо синхронизировать время по разному
		bool NewFrameReady;				//флаг о новом кадре
		DWORD Framebuffer[144][160];	//Буфер для индексов палитры каждого пикселя кадра
		BYTE Backbuffer[144][160];		//Цвета пикселей в значениях палитры
		std::vector<DWORD> SpriteQueue;	//содержит спрайты для отображения

		//LCD
		DWORD ClockCounter;				//счетчик тактов
		DWORD ClocksToNextState;		//число тактов, которое должно пройти до наступления нового состояния.
		bool LCDCInterrupted;			//флаг того, что только один LCDC INT запрашивается за одну линию
		InternalLCDModes LCDMode;

		BYTE WindowLine;

		//OAM DMA(контроллер прямого доступа к памяти)
		bool OAMDMAStarted;				
		WORD OAMDMAProgress;			
		WORD OAMDMASource;	
	};

}